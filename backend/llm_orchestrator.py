from __future__ import annotations

import logging
import re
import time
from typing import Any

from app.core.config import get_settings
from app.core.context import get_memory
from app.prompts.marketing_prompts import build_sql_prompt, build_summary_prompt
from app.services.cache_utils import get_cached_response, store_response
from app.services.clickhouse import get_clickhouse_client
from app.services.llm_factory import get_llm_client
from app.services.sql_validator import allow_only_select
from app.utils.llm_cleaner import clean_sql_output

logger = logging.getLogger(__name__)

SETTINGS = get_settings()
MEMORY = get_memory()


def _strip_think_blocks(text: str) -> str:
    return re.sub(r"<think>.*?</think>", "", text, flags=re.S).strip()


async def run_agent(question: str, user_id: str | None) -> dict[str, Any]:
    start_time = time.perf_counter()
    cached = await get_cached_response(question)
    if cached:
        logger.info("cache_hit question=%s", question[:80])
        if user_id:
            MEMORY.add(user_id, f"Q: {question}")
            MEMORY.add(user_id, f"A: {cached['summary']}")
        return cached

    history = MEMORY.get_recent(user_id) if user_id else []
    recent_history = history[-SETTINGS.max_history_messages :]
    memory_payload = recent_history + [f"Q: {question}"]

    llm = get_llm_client()
    sql_prompt = build_sql_prompt(question, memory_payload)
    sql_raw = await llm.generate_text(sql_prompt)
    sql_raw = _strip_think_blocks(sql_raw)

    sql_clean = clean_sql_output(sql_raw)
    logger.debug("Cleaned SQL: %s", sql_clean)
    if not sql_clean:
        logger.error("Empty SQL output after cleaning for question=%s", question)
        raise ValueError("No valid SQL generated by LLM")

    sql = allow_only_select(sql_clean)

    clickhouse = get_clickhouse_client()
    rows = await clickhouse.execute(sql)

    summary_prompt = build_summary_prompt(question, sql, rows)
    summary_raw = await llm.generate_text(summary_prompt)
    summary = _strip_think_blocks(summary_raw)

    if user_id:
        MEMORY.add(user_id, f"Q: {question}")
        MEMORY.add(user_id, f"A: {summary}")

    payload = {
        "sql": sql,
        "data": rows,
        "summary": summary,
    }

    await store_response(question, sql, payload)

    elapsed = time.perf_counter() - start_time
    logger.info("query_latency_seconds=%.3f", elapsed)
    return payload
